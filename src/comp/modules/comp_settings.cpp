#include "std_include.hpp"
#include "comp_settings.hpp"
#include "shared/common/toml_ext.hpp"

#define CATCH_ERR_PRINT	catch (toml::type_error& err) { \
		shared::common::log("CompSettings", std::format("{}", err.what()), shared::common::LOG_TYPE::LOG_TYPE_ERROR, true); }

namespace comp
{
	std::string get_current_comp_version_string()
	{
		return std::string(std::to_string(COMP_MOD_VERSION_MAJOR) + "." + std::to_string(COMP_MOD_VERSION_MINOR) + "." + std::to_string(COMP_MOD_VERSION_PATCH));
	}

	void comp_settings::write_toml()
	{
		const std::string file_path = shared::globals::root_path + "\\rtx_comp\\comp_settings.toml";
		std::filesystem::create_directories(std::filesystem::path(file_path).parent_path());

		std::ofstream file;
		file.open(file_path.c_str());

		file << "# This file is autogenerated. Valid modifications of settings are considered and will be written back to the file.\n";
		file << "# Installing a new version of the compatibility mod will restore all settings to their defaults.\n";
		file << "CreatedOnCompVersion = \"" << get_current_comp_version_string() << "\"\n\n";

		const std::uint32_t setting_count = sizeof(var_definitions) / sizeof(variable);
		for (auto s = 0u; s < setting_count; s++)
		{
			auto var = reinterpret_cast<variable*>(reinterpret_cast<char*>(&vars) + s * sizeof(variable));

			const auto desc_lines = shared::utils::split(std::string(var->m_desc), '\n');
			for (const auto& line : desc_lines) {
				file << "# " + line << std::endl;
			}

			file << "# Type: " << var->get_str_type() << " || Default: " << var->get_str_value(true) << std::endl;
			file << var->m_name << " = " << var->get_str_value() << std::endl << std::endl;
		}

		file.close();
	}

	bool comp_settings::parse_toml()
	{

#ifndef asd // DEBUG
		std::ifstream file;
		if (shared::utils::open_file_homepath("rtx_comp", "comp_settings.toml", file))
		{
			// file exists
			file.close();

			try
			{
				const std::string file_path = shared::globals::root_path + "\\rtx_comp\\comp_settings.toml";
				auto config = toml::parse(file_path);

				if (config.contains("CreatedOnCompVersion"))
				{
					std::string created_on_comp_version_str;
					auto& val = config.at("CreatedOnCompVersion");
					if (val.is_string())
					{
						try { created_on_comp_version_str = val.as_string(); }
						CATCH_ERR_PRINT;
					}

					if (!created_on_comp_version_str.empty())
					{
						if (created_on_comp_version_str != get_current_comp_version_string())
						{
							write_toml();
							return true;
						}
					}
				}

				// #
				auto to_vec = [](const toml::value& entry, const var_type type, float* default_vec = nullptr)
					{
						std::vector<float> result;

						const size_t size_for_vec =
							type == var_type_vec2 ? 2u :
							type == var_type_vec3 ? 3u :
							type == var_type_vec4 ? 4u : 0u;

						if (entry.is_array())
						{
							if (entry.as_array().size() == size_for_vec)
							{
								for (const auto& val : entry.as_array())
								{
									if (val.is_floating())
									{
										result.push_back((float)val.as_floating());
										continue;
									}

									TOML_ERROR("[CompSettings] #to_vec", val, "expected float but got value_t of => %d ", val.type());
								}

								return result;
							}

							TOML_ERROR("[CompSettings] #to_vec", entry, "unexpected array size of => %d ", entry.as_array().size());
						}

						TOML_ERROR("[CompSettings] #to_vec", entry, "expected a vector but got value_t => %d ", entry.type());

						switch (type)
						{
						default:
							result = { 0, 0, 0, 0 };
							break;
						case var_type_vec2:
							result = { default_vec[0], default_vec[1] };
							break;
						case var_type_vec3:
							result = { default_vec[0], default_vec[1], default_vec[2] };
							break;
						case var_type_vec4:
							result = { default_vec[0], default_vec[1], default_vec[2], default_vec[3] };
							break;
						}

						return result;
					};

				// ---------------------------------------

			#define ASSIGN(name)																								\
				if (config.contains((#name))) {																					\
					switch (vars.##name.get_type()) {																			\
						case (var_type_boolean):																				\
							vars.##name.set_var(shared::common::toml_ext::to_bool(config.at(#name), vars.##name.get_as<bool>()), true); break;			\
						case (var_type_integer):																				\
							vars.##name.set_var(shared::common::toml_ext::to_int(config.at(#name), vars.##name.get_as<int>()), true); break;				\
						case (var_type_value):																					\
							vars.##name.set_var(shared::common::toml_ext::to_float(config.at(#name), vars.##name.get_as<float>()), true); break;			\
						case (var_type_vec2):																					\
						case (var_type_vec3):																					\
						case (var_type_vec4):																					\
							const auto vec = to_vec(config.at(#name), vars.##name.get_type(), vars.##name.get_as<float*>());	\
							vars.##name.set_vec(vec.data(), true); break;														\
					}																											\
				}

				// remix related settings
				ASSIGN(remix_override_rtxdi_samplecount);
				
				// culling related settings
				//ASSIGN(nocull_distance_scenery);
				ASSIGN(nocull_distance_meshes);
				//ASSIGN(nocull_disable_precull);

				// material related settings
				
#define MAT_OPTIONS_ASSIGN(VAR)						\
	ASSIGN(VAR##_roughness);						\
	ASSIGN(VAR##_metalness);						\
	ASSIGN(VAR##_view_scalar);						\
	ASSIGN(VAR##_view_primary_color_scalar);		\
	ASSIGN(VAR##_view_primary_color_blend_scalar);	\

				MAT_OPTIONS_ASSIGN(mat_perl);
				MAT_OPTIONS_ASSIGN(mat_matte);
				MAT_OPTIONS_ASSIGN(mat_metallic);
				MAT_OPTIONS_ASSIGN(mat_high_gloss);
				MAT_OPTIONS_ASSIGN(mat_iridiance);
				MAT_OPTIONS_ASSIGN(mat_candy);
				MAT_OPTIONS_ASSIGN(mat_chrome);

#undef MAT_OPTIONS_ASSIGN

				// light translation related settings
				
				// emissive related settings
				
				// general rendering related settings
				

				
			#undef ASSIGN
			}

			catch (const toml::syntax_error& err)
			{
				shared::common::log("CompSettings", std::format("{}", err.what()), shared::common::LOG_TYPE::LOG_TYPE_ERROR, true);
				shared::common::log("CompSettings", "Not writing defaults! Please check 'comp_settings.toml' or remove the file to re-generate it on next startup!", shared::common::LOG_TYPE::LOG_TYPE_ERROR, true);
				return false;
			}
		}
#endif

		// always re-write file
		write_toml();
		return true;
	}

	comp_settings::comp_settings()
	{
		parse_toml();

		// -----
		m_initialized = true;
		shared::common::log("CompSettings", "Module initialized.", shared::common::LOG_TYPE::LOG_TYPE_DEFAULT, false);
	}
}
